import { PDFDocument, StandardFonts, rgb } from "pdf-lib";

/**
 * Generate a PDF report from audit data
 * 
 * @param contractName Name of the audited contract
 * @param contractCode The smart contract code
 * @param auditResult The audit result from AI analysis
 * @returns A Blob containing the PDF file
 */
export async function generatePDF(
  contractName: string,
  contractCode: string,
  auditResult: string
): Promise<Blob> {
  try {
    // Pre-process the text to remove newline characters
    // This is critical to prevent PDF encoding issues as recommended
    const safeAuditResult = auditResult.replace(/\n/g, " ");
    
    // Create a new PDF document
    const pdfDoc = await PDFDocument.create();
    
    // Add fonts
    const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    const courier = await pdfDoc.embedFont(StandardFonts.Courier);
    
    // Create a title page
    const titlePage = pdfDoc.addPage();
    const { width, height } = titlePage.getSize();
    
    // Add title page content
    titlePage.drawText("Smart Contract Audit Report", {
      x: 50,
      y: height - 100,
      size: 24,
      font: helveticaBold,
      color: rgb(0, 0, 0),
    });
    
    titlePage.drawText(contractName, {
      x: 50,
      y: height - 140,
      size: 18,
      font: helveticaFont,
      color: rgb(0, 0, 0),
    });
    
    titlePage.drawText(`Generated by AuditWarp on ${new Date().toLocaleDateString()}`, {
      x: 50,
      y: height - 170,
      size: 12,
      font: helveticaFont,
      color: rgb(0, 0, 0),
    });
    
    // Add contract info
    titlePage.drawText("Audit Information:", {
      x: 50,
      y: height - 230,
      size: 14,
      font: helveticaBold,
      color: rgb(0, 0, 0),
    });
    
    titlePage.drawText(`Contract Name: ${contractName}`, {
      x: 50,
      y: height - 255,
      size: 12,
      font: helveticaFont,
      color: rgb(0, 0, 0),
    });
    
    titlePage.drawText(`Audit Date: ${new Date().toLocaleDateString()}`, {
      x: 50,
      y: height - 275,
      size: 12,
      font: helveticaFont,
      color: rgb(0, 0, 0),
    });
    
    titlePage.drawText("Auditor: AuditWarp AI (powered by Google Gemini)", {
      x: 50,
      y: height - 295,
      size: 12,
      font: helveticaFont,
      color: rgb(0, 0, 0),
    });
    
    // Add "Certified by AuditWarp" stamp - simple version without rotation
    titlePage.drawRectangle({
      x: width - 200,
      y: height - 200,
      width: 150,
      height: 60,
      borderWidth: 2,
      borderColor: rgb(0.8, 0, 0),
      color: rgb(0.95, 0.95, 0.95),
    });
    
    titlePage.drawText("CERTIFIED BY", {
      x: width - 170,
      y: height - 165,
      size: 12,
      font: helveticaBold,
      color: rgb(0.8, 0, 0),
    });
    
    titlePage.drawText("AUDITWARP", {
      x: width - 165,
      y: height - 180,
      size: 16,
      font: helveticaBold,
      color: rgb(0.8, 0, 0),
    });
    
    // Add disclaimer
    titlePage.drawText("Disclaimer:", {
      x: 50,
      y: height - 355,
      size: 10,
      font: helveticaBold,
      color: rgb(0, 0, 0),
    });
    
    const disclaimer = "This audit report is provided as-is without any warranties. While we strive for accuracy, this automated analysis may not capture all potential vulnerabilities. Always conduct additional security reviews before deploying in production.";
    
    titlePage.drawText(disclaimer, {
      x: 50,
      y: height - 370,
      size: 8,
      font: helveticaFont,
      color: rgb(0, 0, 0),
      maxWidth: width - 100,
    });
    
    // Create a single audit findings page with simplified text rendering
    const auditPage = pdfDoc.addPage();
    auditPage.drawText("Audit Findings", {
      x: 50,
      y: height - 50,
      size: 16,
      font: helveticaBold,
      color: rgb(0, 0, 0),
    });
    
    // Draw audit text with simple chunking to avoid issues
    const margin = 50;
    const maxWidth = width - (margin * 2);
    const maxCharsPerLine = 80;
    let yPosition = height - 80;
    
    // Split the preprocessed text into manageable chunks
    // This simplified approach avoids layout calculation issues
    for (let i = 0; i < safeAuditResult.length; i += maxCharsPerLine) {
      const textChunk = safeAuditResult.substring(i, i + maxCharsPerLine);
      
      if (yPosition < margin) {
        break; // Stop if we run out of space (limit to one page for safety)
      }
      
      auditPage.drawText(textChunk, {
        x: margin,
        y: yPosition,
        size: 10,
        font: helveticaFont,
        color: rgb(0, 0, 0),
      });
      
      yPosition -= 12;
    }
    
    // Add code summary page with simplified approach
    const codePage = pdfDoc.addPage();
    codePage.drawText("Contract Code Summary", {
      x: 50,
      y: height - 50,
      size: 16, 
      font: helveticaBold,
      color: rgb(0, 0, 0),
    });
    
    // Simplified code display - show first few characters only
    codePage.drawText("Contract code excerpt:", {
      x: 50,
      y: height - 80,
      size: 10,
      font: helveticaFont,
      color: rgb(0, 0, 0),
    });
    
    // Safe excerpt with limited length
    const codeExcerpt = contractCode.length > 500 
      ? contractCode.substring(0, 500) + "..." 
      : contractCode;
    
    codePage.drawText(codeExcerpt.replace(/\n/g, " "), {
      x: 50,
      y: height - 100,
      size: 8,
      font: courier,
      color: rgb(0, 0, 0),
      maxWidth: width - 100,
    });
    
    codePage.drawText("[Code truncated for PDF rendering...]", {
      x: 50,
      y: height - 200,
      size: 10,
      font: helveticaFont,
      color: rgb(0.5, 0.5, 0.5),
    });
    
    // Add "Certified by AuditWarp" watermark on each page
    for (let i = 0; i < pdfDoc.getPageCount(); i++) {
      const page = pdfDoc.getPage(i);
      page.drawText("Certified by AuditWarp", {
        x: width / 2 - 60,
        y: 30,
        size: 8,
        font: helveticaFont,
        color: rgb(0.7, 0.7, 0.7),
      });
    }
    
    // Serialize the PDF document
    const pdfBytes = await pdfDoc.save();
    return new Blob([pdfBytes], { type: 'application/pdf' });
  } catch (error) {
    console.error("PDF generation error:", error);
    throw new Error("Failed to generate PDF report");
  }
}
